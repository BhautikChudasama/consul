package generate

import (
	"fmt"
	"path/filepath"
	"sort"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"

	"github.com/hashicorp/consul/proto-public/pbresource"
)

func Generate(gp *protogen.Plugin, prefix string) error {
	g := newGenerator()

	for _, file := range gp.Files {
		err := g.addResourceKindsFromFile(file)
		if err != nil {
			return err
		}
	}

	return g.generateTypes(gp, prefix)
}

type apiGroupVersion struct {
	Group   string
	Version string
}

type groupInfo struct {
	Name    string
	Version string

	Kinds       []kind
	ImportPath  protogen.GoImportPath
	PackageName protogen.GoPackageName
	Directory   string
}

type kind struct {
	Name     string
	Scope    string
	Comments protogen.CommentSet
}

type generator struct {
	resources map[apiGroupVersion]*groupInfo
}

func newGenerator() *generator {
	return &generator{
		resources: make(map[apiGroupVersion]*groupInfo),
	}
}

func (g *generator) addResourceKindsFromFile(f *protogen.File) error {
	if !f.Generate {
		return nil
	}

	for _, m := range f.Messages {
		spec, annotated, err := pbresource.GetResourceSpec(m.Desc)
		if !annotated {
			continue
		}
		if err != nil {
			return err
		}

		apiGroupDir := filepath.Dir(f.Proto.GetName())

		gv := apiGroupVersion{
			Group:   spec.Type.Group,
			Version: spec.Type.GroupVersion,
		}

		grp, err := g.ensureAPIGroup(gv, f.GoImportPath, f.GoPackageName, apiGroupDir)
		if err != nil {
			return err
		}

		grp.Kinds = append(grp.Kinds, kind{Name: spec.Type.Kind, Comments: m.Comments, Scope: pbresource.Scope_name[int32(spec.Scope)]})
	}

	return nil
}

func (g *generator) ensureAPIGroup(gv apiGroupVersion, importPath protogen.GoImportPath, pkg protogen.GoPackageName, dir string) (*groupInfo, error) {
	grp, found := g.resources[gv]
	if !found {
		grp = &groupInfo{
			Name:    gv.Group,
			Version: gv.Version,

			ImportPath:  importPath,
			PackageName: pkg,
			Directory:   dir,
		}
		g.resources[gv] = grp
	} else if grp.ImportPath != importPath {
		return nil, fmt.Errorf("resources from the same api group must share the same import path - group: %s, version: %s, original import path: %s, new import path: %s", gv.Group, gv.Version, grp.ImportPath, importPath)
	}

	return grp, nil
}

func (g *generator) generateTypes(gp *protogen.Plugin, prefix string) error {
	for _, info := range g.resources {
		f := gp.NewGeneratedFile(filepath.Join(info.Directory, fmt.Sprintf("%s.go", prefix)), info.ImportPath)

		sort.Slice(info.Kinds, func(a, b int) bool {
			return info.Kinds[a].Name < info.Kinds[b].Name
		})

		if err := typesTemplate.Execute(f, info); err != nil {
			return err
		}
	}
	return nil
}

var (
	typesTemplate = template.Must(template.New("types").Parse(`
// Code generated by protoc-gen-resource-types. DO NOT EDIT.

package {{.PackageName}}

{{if ne .PackageName "pbresource" -}}
import (	
	"github.com/hashicorp/consul/proto-public/pbresource"
)
{{- end}}

const (
	GroupName = "{{.Name}}"
	Version = "{{.Version}}"
)

{{range $kind := .Kinds}}
// {{$.Name}}.{{$.Version}}.{{$kind.Name}} resource type utilities and constants

const {{$kind.Name}}Kind = "{{$kind.Name}}"
const {{$kind.Name}}Scope = {{if ne $.PackageName "pbresource"}}pbresource.{{end}}Scope_{{$kind.Scope}}

var {{$kind.Name}}Type = &{{if ne $.PackageName "pbresource"}}pbresource.{{end}}Type{
	Group:        GroupName,
	GroupVersion: Version,
	Kind:         {{$kind.Name}}Kind,
}

func (_ *{{$kind.Name}}) GetResourceType() *{{if ne $.PackageName "pbresource"}}pbresource.{{end}}Type {
	return {{$kind.Name}}Type
}

func (_ *{{$kind.Name}}) GetResourceScope() {{if ne $.PackageName "pbresource"}}pbresource.{{end}}Scope {
	return {{$kind.Name}}Scope
}
{{- end}}
`))
)
