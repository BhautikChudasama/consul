package generate

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"

	"github.com/hashicorp/consul/internal/resource"
	"github.com/hashicorp/consul/proto-public/pbresource"
)

func Generate(gp *protogen.Plugin) error {
	g := newGenerator()

	for _, file := range gp.Files {
		err := g.addResourceKindsFromFile(file)
		if err != nil {
			return err
		}
	}

	return g.generateTypes(gp)
}

type apiGroupVersion struct {
	Group   string
	Version string
}

type groupInfo struct {
	Name    string
	Version string

	Kinds       []kind
	ImportPath  protogen.GoImportPath
	PackageName protogen.GoPackageName
	Directory   string
}

type kind struct {
	Type     *pbresource.Type
	Scope    string
	Comments protogen.CommentSet
}

type generator struct {
	resources map[apiGroupVersion]*groupInfo
}

func newGenerator() *generator {
	return &generator{
		resources: make(map[apiGroupVersion]*groupInfo),
	}
}

func getKindFromMessageDescriptor(m *protogen.Message) (bool, kind, error) {
	ext := proto.GetExtension(m.Desc.Options(), pbresource.E_Spec).(*pbresource.ResourceTypeSpec)
	if ext == nil {
		return false, kind{}, nil
	}

	var rtype = ext.OverrideType

	if rtype == nil {
		// All protobuf packages that resources are in are prefixed with hashicorp.consul so we can remove that.
		// Some protobuf resources exist in proto-private (looking at you demo resources) and for those they also
		// have an internal in the name that needs stripping.
		gvkString := strings.TrimPrefix(strings.TrimPrefix(string(m.Desc.FullName()), "hashicorp.consul."), "internal.")
		var err error
		rtype, err = resource.ParseGVK(gvkString)
		if err != nil {
			return true, kind{}, err
		}
	}

	if err := resource.ValidateType(rtype); err != nil {
		return true, kind{}, err
	}

	_, valid := pbresource.Scope_name[int32(ext.Scope)]
	if !valid {
		return true, kind{}, fmt.Errorf("invalid resource scope %q", ext.Scope)
	}

	return true, kind{Type: rtype, Scope: ext.Scope.String(), Comments: m.Comments}, nil
}

func (g *generator) addResourceKindsFromFile(f *protogen.File) error {
	if !f.Generate {
		return nil
	}

	for _, m := range f.Messages {
		isResource, msgKind, err := getKindFromMessageDescriptor(m)
		if !isResource {
			continue
		}
		if err != nil {
			return err
		}

		apiGroupDir := filepath.Dir(f.Proto.GetName())

		gv := apiGroupVersion{
			Group:   msgKind.Type.Group,
			Version: msgKind.Type.GroupVersion,
		}

		grp, err := g.ensureAPIGroup(gv, f.GoImportPath, f.GoPackageName, apiGroupDir)
		if err != nil {
			return err
		}

		grp.Kinds = append(grp.Kinds, msgKind)
	}

	return nil
}

func (g *generator) ensureAPIGroup(gv apiGroupVersion, importPath protogen.GoImportPath, pkg protogen.GoPackageName, dir string) (*groupInfo, error) {
	grp, found := g.resources[gv]
	if !found {
		grp = &groupInfo{
			Name:    gv.Group,
			Version: gv.Version,

			ImportPath:  importPath,
			PackageName: pkg,
			Directory:   dir,
		}
		g.resources[gv] = grp
	} else if grp.ImportPath != importPath {
		return nil, fmt.Errorf("resources from the same api group must share the same import path")
	}

	return grp, nil
}

func (g *generator) generateTypes(gp *protogen.Plugin) error {
	for _, info := range g.resources {
		f := gp.NewGeneratedFile(filepath.Join(info.Directory, "resources.rtypes.go"), info.ImportPath)

		sort.Slice(info.Kinds, func(a, b int) bool {
			return info.Kinds[a].Type.Kind < info.Kinds[b].Type.Kind
		})

		if err := typesTemplate.Execute(f, info); err != nil {
			return err
		}
	}
	return nil
}

var (
	typesTemplate = template.Must(template.New("types").Parse(`
// Code generated by protoc-gen-resource-types. DO NOT EDIT.

package {{.PackageName}}

import (	
	"github.com/hashicorp/consul/proto-public/pbresource"
)

const (
   GroupName = "{{.Name}}"
   Version = "{{.Version}}"
)

{{range $kind := .Kinds}}
/* ---------------------------------------------------------------------------
 * {{$.Name}}.{{$.Version}}.{{$kind.Type.Kind}}
 *
 * This following section contains constants variables and utility methods
 * for interacting with this kind of resource.
 * -------------------------------------------------------------------------*/ 
const (
   {{$kind.Type.Kind}}Kind = "{{$kind.Type.Kind}}"
	{{$kind.Type.Kind}}Scope = pbresource.Scope_{{$kind.Scope}}
)
var {{$kind.Type.Kind}}Type = &pbresource.Type{
   Group: GroupName,
   GroupVersion: Version,
   Kind: {{$kind.Type.Kind}}Kind,
}

func (_ *{{$kind.Type.Kind}}) GetResourceType() *pbresource.Type {
   return {{$kind.Type.Kind}}Type
}

func (_ *{{$kind.Type.Kind}}) GetResourceScope() pbresource.Scope {
   return {{$kind.Type.Kind}}Scope
}
{{- end}}
`))
)
