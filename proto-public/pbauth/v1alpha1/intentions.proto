// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

syntax = "proto3";

package hashicorp.consul.auth.v1alpha1;

import "pbresource/resource.proto";

message Intentions {
  // destination is a reference to a specific WorkloadIdentity resource.
  // This must point to a specific resource. To apply intentions to all identities
  // within a namespace, use NamespacedIntentions, and to apply intentions rules to all identities within
  // a partition, use PartitionedIntentions.
  hashicorp.consul.resource.Reference destination = 1;

  // Action can be either allow or deny for the entire object.
  //
  // If action is allow,
  // we will allow the connection if one of the rules in Rules matches, in other words, we will deny
  // all requests except for the ones that match Rules. If Consul is in default allow mode, then allow
  // actions have no effect without a deny permission as everything is allowed by default.
  //
  // If action is deny,
  // we will deny the connection if one of the rules in Rules match, in other words,
  // we will allow all requests except for the ones that match Rules.
  Action action = 2;

  // rules is a list of rules in this Intention. Rules are evaluated in order that they are provided
  // and are applied using OR semantics.
  repeated Rule rules = 3;
}

enum Action {
  ACTION_ALLOW = 0;
  ACTION_DENY = 1;
}

message Rule {
  // sources is a list of sources in this intention. Different sources will be OR'ed together
  // and will be evaluated in order to find a match. For example, if a namespace reference source
  // is provided before the specific identity from the same source namespace, the namespace reference will
  // be matched first because it's provided before the the specific identity.
  repeated Source sources = 1;

  // permissions is a list of permissions to apply for matching sources in this Rule. Permissions
  // are applied using OR semantics.
  repeated Permission permissions = 2;
}

// A source of intention can be either:
//  * an identity within a namespace and partition
//  * an identity within a namespace and peer
//  * an identity within a namespace and sameness group
//  * all identities within a namespace
//  * all identities within a partition
//  * all identities within a peer
//  * all identities within a sameness group
message Source {
  oneof source_ref {
    // identity_ref can be used when the source has a specific identity associated with it.
    IdentityRef identity_ref = 1;

    // namespace_ref can be used to say that the source is all identities within a namespace.
    NamespaceRef namespace_ref = 2;

    // partition_ref can be used to say that the source is all identities within a partition.
    string partition_ref = 3;

    // peer_ref should can be used to say that the source is all identities within a peer.
    string peer_ref = 4;

    // sameness_group_ref can be used to say that the source is all identities within a sameness group.
    string sameness_group_ref = 5;

    // not can be used to negate the source. For example, to say that the source is not a certain identity.
    // It cannot reference another NotRef and can only be one of the other reference types. This will be enforced
    // by the validation hook of this resource.
    Source not = 6;
  }
}

// IdentityRef is reference to a specific identity belonging to a namespace and
// a partition, a peer, or a sameness group.
message IdentityRef {
  string name = 1;
  string namespace = 2;
  oneof peer_or_partition_or_sg {
    string peer = 3;
    string partition = 4;
    string sameness_group = 5;
  }
}

// NamespaceRef is a reference to a namespace.
message NamespaceRef {
  string namespace = 1;
  oneof peer_or_partition_or_sg {
    string peer = 3;
    string partition = 4;
    string sameness_group = 5;
  }
}

message NotRef {
  oneof not_ref {
    // identity_ref can be used when the source has a specific identity associated with it.
    IdentityRef identity_ref = 1;

    // namespace_ref can be used to say that the source is all identities within a namespace.
    NamespaceRef namespace_ref = 2;

    // partition_ref can be used to say that the source is all identities within a partition.
    string partition_ref = 3;

    // peer_ref should can be used to say that the source is all identities within a peer.
    string peer_ref = 4;

    // sameness_group_ref can be used to say that the source is all identities within a sameness group.
    string sameness_group_ref = 5;
  }
}

message Permission {
  oneof perm {
    PermissionRule rule = 1;
    PermissionRule not_rule = 2;
  }
}

message PermissionRule {
  // http specifies L7 permission rules. If destination_ports have non-L7 protocols,
  // this rule is not considered valid. These rules will be ignored for any ports with non-L7 protocols when action is ALLOW.
  // If action is DENY,
  HTTPPermissionRules http = 1;

  // destination_ports is a list of ports to apply this rule to. The ports specified here
  // must be the ports used in the connection. The list
  // values are OR'ed together if multiple are provided. If no ports provided,
  // this rule will apply to all ports.
  repeated uint32 destination_ports = 2;
}

message HTTPPermissionRules {
  string path_exact = 1;
  string path_prefix = 2;
  string path_regex = 3;

  // methods is the list of HTTP methods. If no methods are specified,
  // this rule will apply to all methods.
  repeated string methods = 4;

  PermissionHeader header = 5;
}

message NotPermissionRule {
  PermissionRule not_permission = 1;
}

message PermissionHeader {
  string name = 1;
  bool present = 2;
  string exact = 3;
  string prefix = 4;
  string suffix = 5;
  string regex = 6;
  bool invert = 7;
}

// todo: figure out jwt
// todo: description?
